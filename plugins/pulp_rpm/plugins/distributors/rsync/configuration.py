# -*- coding: utf-8 -*-
#
# Copyright Â© 2013 Red Hat, Inc.
#
# This software is licensed to you under the GNU General Public License as
# published by the Free Software Foundation; either version 2 of the License
# (GPLv2) or (at your option) any later version.
# There is NO WARRANTY for this software, express or implied, including the
# implied warranties of MERCHANTABILITY, NON-INFRINGEMENT, or FITNESS FOR A
# PARTICULAR PURPOSE.
# You should have received a copy of GPLv2 along with this software;
# if not, see http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt

import os
import urlparse

#from pulp.server.managers.repo.distributor import RepoDistributorManager
from pulp.server.db.model import Distributor
import logging

LOG_PREFIX_NAME="pulp.plugins"
def getLogger(name):
    log_name = LOG_PREFIX_NAME + "." + name
    return logging.getLogger(log_name)
_LOG = getLogger(__name__)

REMOTE_CONTENT_BASE = os.path.join("content", "origin")


class OneOfValidation(object):
    def __init__(self, values):
        self.values = values

    def __call__(self, value):
        if value in self.values:
            return (True, None)
        else:
            return (False, self._err(value))

    def _err(self, value):
        values_str = ", ".join(self.values)
        return "{value} is not in allowed values: {allowed}" % (value, values_str)

class NonEmptyValidation(object):
    def __call__(self, value):
        if value:
            return (True, None)
        else:
            return (False, self._err(value))

    def _err(self, value):
        return "attribute cannot be empty"

class TypeValidation(object):
    def __init__(self, allowed_types):
        self.allowed_types = allowed_types

    def __call__(self, value):
        if [True for _type in self.allowed_types if issubclass(type(value), _type)]:
            return (True, None)
        else:
            return (False, self._err(value))

    def _err(self, value):
        str_types = ", ".join(self.allowed_types)
        return "type of atribute(%s) is not in allowed types: %s" % (type(value), str_types)


# These information are used to locate the repo diretory previously generated by
# YumHTTPDistributor. For the same repo, their values should be the same as set
# for YumHTTPDistributor.
REQUIRED_CONFIG_KEYS = (
    'http',
    'https',
    'handler_type',  # type: str. Copy mechanism. Options: rsync, scp
    'remote',  # type: {}. Configurations of CDN publish.
    )

CDN_MANDATORY_KEYS = {"auth_type": [OneOfValidation(["publickey", "password"])],
                      "key_path": [TypeValidation([basestring]), NonEmptyValidation()],
                      "login": [TypeValidation([basestring]), NonEmptyValidation()],
                      "ssh_login": [TypeValidation([basestring]), NonEmptyValidation()],
                      "host": [TypeValidation([basestring]), NonEmptyValidation()],
                      "root": [TypeValidation([basestring]), NonEmptyValidation()]}

CDN_OPTIONAL_KEYS = ["relative_dir"]

'''
A sample rh_cdn_distributor.conf can look like this:

{
    'http': false,
    'https': true,
    'handler_type': 'rsync',

    'remote': {
        'auth_type': 'publickey',
        'key_path': '/full/path/to/key',
        'login': 'cdn_login_name',
        'ssh_login': 'ssh_login_name',
        'host': 'hostname.domain',
        'root': '/var/lib/cdn/',
        'relative_dir': 'repo_name_or_other_bits_for_path'
    }
}
'''

# The following two configs are copied from the yum_distributor on branch 'pulp-2.3'
# There is better way to do this by sharing these configs with yum_distributor
# instead of duplicating it. This can be done when branch 'pulp-2.4' is present.
HTTP_PUBLISH_DIR = "/var/lib/pulp/published/yum/http/repos"
HTTPS_PUBLISH_DIR = "/var/lib/pulp/published/yum/https/repos"
DOCKER_V1_PUBLISH_DIR = '/var/lib/pulp/published/docker/v1/web'
DOCKER_V2_PUBLISH_DIR = '/var/lib/pulp/published/docker/v2/web'

DOCKER_UNIT_TYPES = ["docker_image"]
DOCKER_V2_UNIT_TYPES = ["docker_manifest","docker_blob"]
RPM_UNIT_TYPES = ["rpm"]

def validate_config(repo, config, config_conduit):
    """
    Validate the prospective configuration instance for the given repository.

    :param repo: repository to validate the config for
    :type  repo: pulp.plugins.model.Repository
    :param config: configuration instance to validate
    :type  config: pulp.plugins.config.PluginCallConfiguration
    :param config_conduit: conduit providing access to relevant Pulp functionality
    :type  config_conduit: pulp.plugins.conduits.repo_config.RepoConfigConduit
    :return: tuple of (bool, str) stating that the configuration is valid or not and why
    :rtype:  tuple of (bool, str or None)
    """
    _config = config.flatten()  # now config is {}
    err_list = []
    crit_fail = False
    if not "cdn" in _config or ("cdn" in _config and not isinstance(_config["cdn"], dict)):
        err_list.append("'cdn' dict missing in distributor's configuration")
        crit_fail = True
    if not crit_fail:
        missing_attr_tmpl = "'%s' missing in 'cdn' section of distributor's configuration"
        for attr, validations in CDN_MANDATORY_KEYS.iteritems():
            if attr not in _config["cdn"]:
                err_list.append(missing_attr_tmpl % attr)
                continue
            for validation in validations:
                succeed, _err = validation(_config["cdn"][attr])
                if not succeed:
                    err_list.append(err)
    if err_list:
        return (False, "\n".join(err_list))
    else:
        return (True, None)


def get_https_publish_dir(config):
    """
    @param config
    @type pulp.server.content.plugins.config.PluginCallConfiguration
    """
    if config:
        publish_dir = config.get("https_publish_dir")
        if publish_dir:
            _LOG.info("Override HTTPS publish directory from passed in config value to: %s" % (publish_dir))
            return publish_dir
    return HTTPS_PUBLISH_DIR


def get_http_publish_dir(config=None):
    """
    @param config
    @type pulp.server.content.plugins.config.PluginCallConfiguration
    """
    if config:
        publish_dir = config.get("http_publish_dir")
        if publish_dir:
            _LOG.info("Override HTTP publish directory from passed in config value to: %s" % (publish_dir))
            return publish_dir
    return HTTP_PUBLISH_DIR


def get_docker_publish_dir(config, version):
    """
    @param config
    @type pulp.server.content.plugins.config.PluginCallConfiguration
    """
    from pulp_docker.common import constants as pulp_docker_constants
    return os.path.join(config.get(pulp_docker_constants.CONFIG_KEY_DOCKER_PUBLISH_DIRECTORY,
                                   pulp_docker_constants.CONFIG_VALUE_DOCKER_PUBLISH_DIRECTORY),
                        version)


def get_docker_web_dir(config, version, repo):
    """
    @param config
    @type pulp.server.content.plugins.config.PluginCallConfiguration
    """
    return os.path.join(get_docker_publish_dir(config, version), 'web',
                        repo.id)


def get_docker_master_dir(config, version, repo):
    """
    @param config
    @type pulp.server.content.plugins.config.PluginCallConfiguration
    """
    return os.path.join(get_docker_publish_dir(config, version),
                        'master', repo.id)


def get_repo_relative_path(repo, config, **kwargs):
    repo_type = repo.notes.get('_repo-type')
    if repo_type == 'rpm-repo':
        relative_url = repo.notes.get("relative_url", "")
        if relative_url:
            return relative_url
        else:
            return repo.id
    elif repo_type == 'docker-repo':
        from pulp_docker.plugins.distributors.configuration import get_redirect_url
        distributor = Distributor.objects.get_or_404(repo_id=repo.id,
                                             distributor_type_id="docker_distributor_web")

        url = get_redirect_url(distributor["config"], repo, kwargs["docker_version"])
        parsed = urlparse.urlparse(url)
        if "stage" in parsed.netloc or "qa" in parsed.netloc:
            return parsed.path
        elif "access" in parsed.netloc:
            return parsed.path.replace("/webassets/docker/", "")
        else:
            return repo.id
    else:
        return config.get("relative_url")

def get_remote_content_base(config):
    remote_content_base = config.get("relative_url")
    if not remote_content_base:
        return REMOTE_CONTENT_BASE
    return remote_content_base


#def get_repo_dir(repo, config):
#    """
#    Get the dir of repodata directory generated by YumHTTPDistributor.
#
#    :param repo: repository to get dir for
#    :type  repo: pulp.plugins.model.Repository
#    :param config: configuration instance to validate
#    :type  config: pulp.plugins.config.PluginCallConfiguration
#    :return: str the directory of repo
#    :rtype:  str or None
#    """
#    d_config = config.flatten()
#
#    repo_base_dir = None
#    repo_type = repo.notes.get('_repo-type')
#    if repo_type == 'rpm-repo':
#        if d_config.get('http') is True:
#            repo_base_dir = get_http_publish_dir(config)
#        else:
#            repo_base_dir = get_https_publish_dir(config)
#    elif repo_type == 'docker-repo':
#        repo_base_dir = get_docker_publish_dir(config)
#    repo_rel_dir = get_repo_relative_path(repo, config)
#
#    return (repo_base_dir, repo_rel_dir)

def get_include_repodata(repo, config):
    """
    Return whether or not repodata should be included in the rsync

    :param repo: repository to get dir for
    :type  repo: pulp.plugins.model.Repository
    :param config: configuration instance to validate
    :type  config: pulp.plugins.config.PluginCallConfiguration
    :return: whether to include the repodata in the rsync
    :rtype:  boolean
    """
    try:
        if repo.notes.get("rsync_repodata") is not None:
            return repo.notes.get("rsync_repodata").lower() == 'true'

        d_config = config.flatten()
        return str(d_config.get('cdn', {}).get('skip_repodata', 'True')).lower() != 'true'
    except:
        return False

